import { OBSERVER_TYPE, decorators, LOAD_SCENE_MODE, System } from '@eva/eva.js';
import { Container, Application } from '@eva/renderer-adapter';
import isEqual from 'lodash-es/isEqual';
import EventEmitter from 'eventemitter3';
import { ticker } from 'pixi.js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var RendererManager = (function () {
    function RendererManager(_a) {
        var game = _a.game, rendererSystem = _a.rendererSystem;
        this.renderers = [];
        this.game = game;
        this.rendererSystem = rendererSystem;
    }
    RendererManager.prototype.register = function () {
        var e_1, _a;
        var renderers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            renderers[_i] = arguments[_i];
        }
        try {
            for (var renderers_1 = __values(renderers), renderers_1_1 = renderers_1.next(); !renderers_1_1.done; renderers_1_1 = renderers_1.next()) {
                var renderer = renderers_1_1.value;
                renderer.game = this.game;
                renderer.rendererManager = this.rendererSystem.rendererManager;
                renderer.containerManager = this.rendererSystem.containerManager;
                this.renderers.push(renderer);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (renderers_1_1 && !renderers_1_1.done && (_a = renderers_1.return)) _a.call(renderers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    RendererManager.prototype.componentChanged = function (changes) {
        var e_2, _a;
        var _loop_1 = function (changed) {
            var e_3, _a;
            try {
                for (var _b = (e_3 = void 0, __values(this_1.renderers)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var renderer = _c.value;
                    var props = renderer.observerInfo[changed.componentName];
                    if (props) {
                        if ([OBSERVER_TYPE.ADD, OBSERVER_TYPE.REMOVE].indexOf(changed.type) > -1) {
                            try {
                                renderer.componentChanged && renderer.componentChanged(changed);
                            }
                            catch (e) {
                                console.error("gameObject: " + changed.gameObject.name + ", " + changed.componentName + " is error.", changed, e);
                            }
                            continue;
                        }
                        var index = props.findIndex(function (prop) {
                            return isEqual(prop, changed.prop);
                        });
                        if (index > -1) {
                            try {
                                renderer.componentChanged && renderer.componentChanged(changed);
                            }
                            catch (e) {
                                console.error("gameObject: " + (changed.gameObject && changed.gameObject.name) + ", " + changed.componentName + " is componentChanged error.", changed, e);
                            }
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        var this_1 = this;
        try {
            for (var changes_1 = __values(changes), changes_1_1 = changes_1.next(); !changes_1_1.done; changes_1_1 = changes_1.next()) {
                var changed = changes_1_1.value;
                _loop_1(changed);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (changes_1_1 && !changes_1_1.done && (_a = changes_1.return)) _a.call(changes_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    RendererManager.prototype.update = function (gameObject) {
        var e_4, _a, e_5, _b;
        try {
            for (var _c = __values(gameObject.components), _d = _c.next(); !_d.done; _d = _c.next()) {
                var component = _d.value;
                try {
                    for (var _e = (e_5 = void 0, __values(this.renderers)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var renderer = _f.value;
                        var cache = [];
                        var props = renderer.observerInfo[component.name];
                        if (props && cache.indexOf(gameObject) === -1) {
                            cache.push(gameObject);
                            try {
                                renderer.rendererUpdate && renderer.rendererUpdate(gameObject);
                            }
                            catch (e) {
                                console.info("gameObject: " + gameObject.name + ", " + component.name + " is update error", e);
                            }
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    return RendererManager;
}());

var ContainerManager = (function () {
    function ContainerManager() {
        this.containerMap = {};
    }
    ContainerManager.prototype.addContainer = function (_a) {
        var name = _a.name, container = _a.container;
        this.containerMap[name] = container;
    };
    ContainerManager.prototype.getContainer = function (name) {
        return this.containerMap[name];
    };
    ContainerManager.prototype.removeContainer = function (name) {
        delete this.containerMap[name];
    };
    ContainerManager.prototype.updateTransform = function (_a) {
        var name = _a.name, transform = _a.transform;
        var container = this.containerMap[name];
        if (!container)
            return;
        var anchor = transform.anchor, origin = transform.origin, position = transform.position, rotation = transform.rotation, scale = transform.scale, size = transform.size, skew = transform.skew;
        container.rotation = rotation;
        container.scale = scale;
        container.pivot.x = size.width * origin.x;
        container.pivot.y = size.height * origin.y;
        container.skew = skew;
        var x = position.x;
        var y = position.y;
        if (transform.parent) {
            var parent_1 = transform.parent;
            x = x + parent_1.size.width * anchor.x;
            y = y + parent_1.size.height * anchor.y;
        }
        container.position = { x: x, y: y };
    };
    return ContainerManager;
}());

var Transform = (function (_super) {
    __extends(Transform, _super);
    function Transform(_a) {
        var system = _a.system, containerManager = _a.containerManager;
        var _this = _super.call(this) || this;
        _this.name = 'Transform';
        _this.waitRemoveIds = [];
        _this.waitChangeScenes = [];
        _this.containerManager = containerManager;
        _this.init(system);
        return _this;
    }
    Transform.prototype.init = function (system) {
        var _this = this;
        this.system = system;
        this.on('changeScene', function (_a) {
            var scene = _a.scene, mode = _a.mode, application = _a.application;
            _this.waitChangeScenes.push({ scene: scene, mode: mode, application: application });
        });
    };
    Transform.prototype.update = function () {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(this.waitRemoveIds), _d = _c.next(); !_d.done; _d = _c.next()) {
                var id = _d.value;
                this.containerManager.removeContainer(id);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.waitRemoveIds = [];
        try {
            for (var _e = __values(this.waitChangeScenes), _f = _e.next(); !_f.done; _f = _e.next()) {
                var sceneInfo = _f.value;
                var container = this.containerManager.getContainer(sceneInfo.scene.id);
                if (container) {
                    sceneInfo.application.stage.removeChildren();
                    sceneInfo.application.stage.addChild(container);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.waitChangeScenes = [];
    };
    Transform.prototype.componentChanged = function (changed) {
        if (changed.type === OBSERVER_TYPE.ADD) {
            this.addContainer(changed);
        }
        else if (changed.type === OBSERVER_TYPE.CHANGE) {
            this.change(changed);
        }
        else if (changed.type === OBSERVER_TYPE.REMOVE) {
            this.waitRemoveIds.push(changed.gameObject.id);
        }
    };
    Transform.prototype.addContainer = function (changed) {
        var container = new Container();
        container.name = changed.gameObject.name;
        this.containerManager.addContainer({
            name: changed.gameObject.id,
            container: container,
        });
        var transform = changed.component;
        transform.worldTransform = container.transform.worldTransform;
    };
    Transform.prototype.change = function (changed) {
        var transform = changed.component;
        if (transform.parent) {
            var parentContainer = this.containerManager.getContainer(transform.parent.gameObject.id);
            parentContainer.addChild(this.containerManager.getContainer(changed.gameObject.id));
            var render = changed.gameObject.transform.parent &&
                changed.gameObject.transform.parent.gameObject.getComponent('Render');
            if (render) {
                render.sortDirty = true;
            }
        }
        else {
            var container = this.containerManager.getContainer(changed.gameObject.id);
            container.parent && container.parent.removeChild(container);
        }
    };
    Transform.prototype.destroy = function () {
        this.removeAllListeners();
        this.waitRemoveIds = null;
        this.waitChangeScenes = null;
        this.system = null;
        this.containerManager = null;
    };
    Transform = __decorate([
        decorators.componentObserver({
            Transform: ['_parent'],
        })
    ], Transform);
    return Transform;
}(EventEmitter));

var RENDERER_TYPE;
(function (RENDERER_TYPE) {
    RENDERER_TYPE[RENDERER_TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE[RENDERER_TYPE["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE[RENDERER_TYPE["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var disableScroll = function (renderer) {
    renderer.plugins.interaction.autoPreventDefault = true;
    renderer.view.style.touchAction = 'none';
};
var enableScroll = function (renderer) {
    renderer.plugins.interaction.autoPreventDefault = false;
    renderer.view.style.touchAction = 'auto';
};
var Renderer$1 = (function (_super) {
    __extends(Renderer, _super);
    function Renderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.multiApps = [];
        return _this;
    }
    Renderer.prototype.init = function (params) {
        var _this = this;
        this.params = params;
        this.application = this.createApplication(params);
        this.containerManager = new ContainerManager();
        this.rendererManager = new RendererManager({
            game: this.game,
            rendererSystem: this,
        });
        this.game.canvas = this.application.view;
        this.transform = new Transform({
            system: this,
            containerManager: this.containerManager,
        });
        this.game.on('sceneChanged', function (_a) {
            var scene = _a.scene, mode = _a.mode, params = _a.params;
            var application;
            switch (mode) {
                case LOAD_SCENE_MODE.SINGLE:
                    application = _this.application;
                    break;
                case LOAD_SCENE_MODE.MULTI_CANVAS:
                    application = _this.createMultiApplication({ params: params });
                    break;
            }
            scene.canvas = application.view;
            _this.transform.emit('changeScene', {
                scene: scene,
                mode: mode,
                application: application,
            });
        });
    };
    Renderer.prototype.registerObserver = function (observerInfo) {
        var _a;
        var thisObserverInfo = this.constructor.observerInfo;
        for (var key in observerInfo) {
            if (!thisObserverInfo[key]) {
                thisObserverInfo[key] = [];
            }
            (_a = thisObserverInfo[key]).push.apply(_a, __spread(observerInfo[key]));
        }
    };
    Renderer.prototype.createMultiApplication = function (_a) {
        var params = _a.params;
        var app = this.createApplication(params);
        this.multiApps.push(app);
        return app;
    };
    Renderer.prototype.createApplication = function (params) {
        params.view = params.canvas;
        if (params.renderType === RENDERER_TYPE.CANVAS) {
            params.forceCanvas = true;
        }
        ticker.shared.autoStart = false;
        ticker.shared.stop();
        var app = new Application(__assign({ sharedTicker: true }, params));
        if (params.preventScroll !== undefined) {
            console.warn('PreventScroll property will deprecate at next major version, please use enableEnable instead. https://eva.js.org/#/tutorials/game');
            params.preventScroll ? enableScroll(app.renderer) : disableScroll(app.renderer);
        }
        if (params.enableScroll !== undefined) {
            params.enableScroll ? enableScroll(app.renderer) : disableScroll(app.renderer);
        }
        if (params.preventScroll === undefined && params.enableScroll === undefined) {
            enableScroll(app.renderer);
        }
        return app;
    };
    Renderer.prototype.update = function (e) {
        var e_1, _a, e_2, _b;
        var changes = this.componentObserver.clear();
        try {
            for (var changes_1 = __values(changes), changes_1_1 = changes_1.next(); !changes_1_1.done; changes_1_1 = changes_1.next()) {
                var changed = changes_1_1.value;
                this.transform.componentChanged(changed);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (changes_1_1 && !changes_1_1.done && (_a = changes_1.return)) _a.call(changes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _c = __values(this.game.gameObjects), _d = _c.next(); !_d.done; _d = _c.next()) {
                var gameObject = _d.value;
                this.containerManager.updateTransform({
                    name: gameObject.id,
                    transform: gameObject.transform,
                });
                this.rendererManager.update(gameObject);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.application.ticker.update(e.time);
    };
    Renderer.prototype.lateUpdate = function () {
        this.transform.update();
    };
    Renderer.prototype.onDestroy = function () {
        var e_3, _a;
        this.application.destroy();
        try {
            for (var _b = __values(this.multiApps), _c = _b.next(); !_c.done; _c = _b.next()) {
                var app = _c.value;
                app && app.destroy();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this.transform.destroy();
        this.transform = null;
        this.params = null;
        this.rendererManager = null;
        this.containerManager = null;
        this.application = null;
        this.game = null;
        this.multiApps = null;
    };
    Renderer.systemName = 'Renderer';
    Renderer = __decorate([
        decorators.componentObserver({
            Transform: ['_parent'],
        })
    ], Renderer);
    return Renderer;
}(System));

var Renderer = (function (_super) {
    __extends(Renderer, _super);
    function Renderer() {
        var _this = _super.call(this) || this;
        _this.observerInfo = _this.constructor.observerInfo;
        return _this;
    }
    Renderer.prototype.update = function () {
        var e_1, _a;
        var changes = this.componentObserver.clear();
        try {
            for (var changes_1 = __values(changes), changes_1_1 = changes_1.next(); !changes_1_1.done; changes_1_1 = changes_1.next()) {
                var changed = changes_1_1.value;
                this.componentChanged(changed);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (changes_1_1 && !changes_1_1.done && (_a = changes_1.return)) _a.call(changes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return Renderer;
}(System));

export { ContainerManager, RENDERER_TYPE, Renderer, RendererManager, Renderer$1 as RendererSystem };
